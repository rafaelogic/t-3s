<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Tetris: Final Cut</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #050505;
            --text-color: #fff;
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-gold: #ffd700;
            --ui-bg: rgba(10, 10, 10, 0.95);
            --border-color: #333;
        }

        body {
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Layout Container - Perfectly Centered */
        #game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px; 
        }

        /* Sidebars - Fixed Equal Widths for Balance */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 140px; /* Fixed width ensures perfect centering */
        }

        .sidebar.left { align-items: flex-end; }
        .sidebar.right { align-items: flex-start; }

        /* The Game Board Wrapper */
        #game-wrapper {
            position: relative;
            border: 4px solid var(--border-color);
            border-radius: 2px;
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.15);
            padding: 0; /* REMOVED PADDING to fix "confusing space" */
            background: #000;
            line-height: 0; /* Removes tiny vertical gaps */
        }

        canvas {
            display: block;
            background-color: #000;
        }

        /* Panels */
        .panel {
            background: var(--ui-bg);
            padding: 15px;
            border: 2px solid #333;
            text-align: center;
            box-shadow: inset 0 0 10px #000;
            border-radius: 6px;
            width: 100%;
            box-sizing: border-box;
        }

        .panel h3 {
            font-size: 9px;
            color: #777;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .value {
            font-size: 14px;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        #high-score { color: var(--neon-gold); text-shadow: 0 0 5px var(--neon-gold); }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            text-align: center;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 32px;
            color: var(--neon-pink);
            text-shadow: 3px 3px 0px var(--neon-blue);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        button {
            background: var(--neon-blue);
            color: #000;
            border: none;
            padding: 15px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 0 15px var(--neon-blue);
            margin-top: 10px;
        }
        button:hover { background: #fff; }

        /* Shake Animation */
        @keyframes shake {
            0% { transform: translate(1px, 1px); }
            25% { transform: translate(-2px, -1px); }
            50% { transform: translate(2px, 1px); }
            75% { transform: translate(-1px, -2px); }
            100% { transform: translate(0, 0); }
        }
        .shake { animation: shake 0.2s; }

        #controls-hint {
            margin-top: 30px;
            font-size: 9px;
            color: #555;
            text-align: center;
            line-height: 2;
        }
        .key { border: 1px solid #444; padding: 3px 5px; border-radius: 3px; color: #ccc; background: #111; }
        
        /* Music Indicator */
        #music-status {
            margin-top: 10px;
            font-size: 8px;
            color: #444;
            text-transform: uppercase;
        }
        .music-on { color: #0f0 !important; text-shadow: 0 0 5px #0f0; }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div class="sidebar left">
            <div class="panel">
                <h3>Hold</h3>
                <canvas id="hold" width="80" height="80"></canvas>
            </div>
            <div class="panel">
                <h3>Lines</h3>
                <div id="lines" class="value">0</div>
            </div>
            <div id="music-status">Music: OFF (Press M)</div>
        </div>

        <div id="game-wrapper">
            <canvas id="tetris" width="240" height="400"></canvas>
            
            <div id="start-screen" class="overlay">
                <h1>NEON<br>TETRIS</h1>
                <button onclick="startGame()">START GAME</button>
                <p style="font-size: 9px; margin-top: 20px; color:#666;">High Score: <span id="start-high-score">0</span></p>
            </div>

            <div id="game-over" class="overlay hidden">
                <h1 style="color: red; text-shadow: none;">GAME OVER</h1>
                <p style="font-size: 10px; margin-bottom:10px;">SCORE</p>
                <div id="final-score" class="value" style="margin-bottom: 20px; font-size: 20px;">0</div>
                <button onclick="resetGame()">TRY AGAIN</button>
            </div>

            <div id="pause-screen" class="overlay hidden">
                <h1>PAUSED</h1>
                <button onclick="togglePause()">RESUME</button>
            </div>
        </div>

        <div class="sidebar right">
            <div class="panel">
                <h3>Next</h3>
                <canvas id="next" width="80" height="80"></canvas>
            </div>
            <div class="panel">
                <h3>Score</h3>
                <div id="score" class="value">0</div>
            </div>
            <div class="panel">
                <h3>Best</h3>
                <div id="high-score" class="value">0</div>
            </div>
            <div class="panel">
                <h3>Level</h3>
                <div id="level" class="value">1</div>
            </div>
        </div>
    </div>

    <div id="controls-hint">
        <span class="key">←</span> <span class="key">→</span> Move &nbsp; 
        <span class="key">↑</span> Rotate &nbsp; 
        <span class="key">↓</span> Soft Drop<br>
        <span class="key">SPACE</span> Hard Drop &nbsp; 
        <span class="key">C</span> Hold &nbsp; 
        <span class="key">P</span> Pause &nbsp;
        <span class="key">M</span> Music
    </div>

<script>
// --- ADVANCED AUDIO ENGINE (Web Audio API) ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

// --- MUSIC SEQUENCER ---
let musicInterval = null;
let isMusicPlaying = false;
let step = 0;

const music = {
    // A dark, cinematic bass sequence
    bass: [
        110.00, 0, 110.00, 0,  // A2
        110.00, 0, 110.00, 0,
        87.31,  0, 87.31,  0,  // F2
        87.31,  0, 87.31,  0,
        98.00,  0, 98.00,  0,  // G2
        98.00,  0, 98.00,  0,
        82.41,  0, 82.41,  0,  // E2
        82.41,  0, 82.41,  0 
    ],
    // Arpeggiated plucks
    lead: [
        0, 440, 0, 523, 
        0, 440, 0, 659, 
        0, 349, 0, 440, 
        0, 349, 0, 523,
        0, 392, 0, 493, 
        0, 392, 0, 587,
        0, 329, 0, 415, 
        0, 329, 0, 493
    ]
};

function playMusicStep() {
    const now = audioCtx.currentTime;
    const lookahead = 0.1; 
    
    // Play Bass (Sawtooth with Lowpass Filter for "Dark" sound)
    const bassFreq = music.bass[step % 32];
    if (bassFreq > 0) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.value = bassFreq / 2; // Drop octave for heavy bass

        filter.type = 'lowpass';
        filter.frequency.value = 400; // Muffle it

        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(now);
        osc.stop(now + 0.3);
    }

    // Play Lead (Sine with fast decay for "Pluck" sound)
    const leadFreq = music.lead[step % 32];
    if (leadFreq > 0) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = 'triangle';
        osc.frequency.value = leadFreq;

        gain.gain.setValueAtTime(0.05, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.start(now);
        osc.stop(now + 0.1);
    }

    step++;
}

function toggleMusic() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    const statusEl = document.getElementById('music-status');
    
    if (isMusicPlaying) {
        clearInterval(musicInterval);
        isMusicPlaying = false;
        statusEl.innerText = "Music: OFF (Press M)";
        statusEl.classList.remove('music-on');
    } else {
        step = 0;
        // 115 BPM roughly calculated to ms
        musicInterval = setInterval(playMusicStep, 130); 
        isMusicPlaying = true;
        statusEl.innerText = "Music: ON (Press M)";
        statusEl.classList.add('music-on');
    }
}

// --- SFX SYSTEM ---
const sfx = {
    tone: (freq, type, dur, vol) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
    },
    move: () => sfx.tone(200, 'triangle', 0.05, 0.05),
    rotate: () => sfx.tone(400, 'square', 0.05, 0.03),
    drop: () => sfx.tone(100, 'sawtooth', 0.1, 0.1),
    hold: () => sfx.tone(300, 'sine', 0.15, 0.1),
    clear: () => {
        sfx.tone(880, 'square', 0.1, 0.05);
        setTimeout(() => sfx.tone(1108, 'square', 0.1, 0.05), 50);
    },
    gameOver: () => {
        sfx.tone(150, 'sawtooth', 0.5, 0.2);
        setTimeout(() => sfx.tone(100, 'sawtooth', 0.5, 0.2), 200);
    }
};

// --- GAME LOGIC ---
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nextContext = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('hold');
const holdContext = holdCanvas.getContext('2d');

context.scale(20, 20);
nextContext.scale(20, 20);
holdContext.scale(20, 20);

const colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
let particles = [];
let isPaused = false;
let isGameOver = false;
let isGameActive = false;
let highScore = localStorage.getItem('neon_tetris_highscore') || 0;

document.getElementById('high-score').innerText = highScore;
document.getElementById('start-high-score').innerText = highScore;

const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    score: 0,
    lines: 0,
    level: 1,
    hold: null,
    canHold: true
};

const arena = createMatrix(10, 20);

function createPiece(type) {
    if (type === 'I') return [[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0]];
    if (type === 'L') return [[0, 2, 0],[0, 2, 0],[0, 2, 2]];
    if (type === 'J') return [[0, 3, 0],[0, 3, 0],[3, 3, 0]];
    if (type === 'O') return [[4, 4],[4, 4]];
    if (type === 'Z') return [[5, 5, 0],[0, 5, 5],[0, 0, 0]];
    if (type === 'S') return [[0, 6, 6],[6, 6, 0],[0, 0, 0]];
    if (type === 'T') return [[0, 7, 0],[7, 7, 7],[0, 0, 0]];
}

function createMatrix(w, h) {
    const matrix = [];
    while (h--) matrix.push(new Array(w).fill(0));
    return matrix;
}

function drawMatrix(matrix, offset, ctx, ghost = false) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                if (ghost) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
                    ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 0.05;
                    ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                } else {
                    ctx.fillStyle = colors[value];
                    ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                    ctx.lineWidth = 0.05;
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                    // Simple shading
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(x + offset.x + 0.1, y + offset.y + 0.8, 0.8, 0.1);
                    ctx.fillRect(x + offset.x + 0.8, y + offset.y + 0.1, 0.1, 0.8);
                }
            }
        });
    });
}

function draw() {
    // Clear Main Board
    context.fillStyle = '#000';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw Grid Background (subtle)
    context.strokeStyle = '#111';
    context.lineWidth = 0.02;
    for(let i=0; i<20; i++) {
        context.beginPath(); context.moveTo(0, i); context.lineTo(10, i); context.stroke();
    }
    for(let i=0; i<10; i++) {
        context.beginPath(); context.moveTo(i, 0); context.lineTo(i, 20); context.stroke();
    }

    drawMatrix(arena, {x: 0, y: 0}, context);

    if(player.matrix && !isGameOver) {
        const ghostPos = {...player.pos};
        while (!collide(arena, {matrix: player.matrix, pos: ghostPos})) {
            ghostPos.y++;
        }
        ghostPos.y--;
        drawMatrix(player.matrix, ghostPos, context, true);
        drawMatrix(player.matrix, player.pos, context);
    }

    // Particles
    particles.forEach((p, i) => {
        p.life--;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.02; // Gravity
        context.fillStyle = p.color;
        context.fillRect(p.x, p.y, 0.15, 0.15);
        if(p.life <= 0) particles.splice(i, 1);
    });
}

function drawSidePanel(ctx, matrix) {
    ctx.fillStyle = '#000';
    ctx.clearRect(0, 0, 4, 4);
    if (matrix) {
        const offset = {
            x: (4 - matrix[0].length) / 2,
            y: (4 - matrix.length) / 2
        };
        drawMatrix(matrix, offset, ctx);
    }
}

function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 &&
               (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                return true;
            }
        }
    }
    return false;
}

function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
        });
    });
}

function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
}

function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        sfx.drop();
        playerReset();
        arenaSweep();
        updateScore();
    }
    dropCounter = 0;
}

function playerMove(dir) {
    player.pos.x += dir;
    if (collide(arena, player)) {
        player.pos.x -= dir;
    } else {
        sfx.move();
    }
}

function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
            rotate(player.matrix, -dir);
            player.pos.x = pos;
            return;
        }
    }
    sfx.rotate();
}

function playerHardDrop() {
    while (!collide(arena, player)) {
        player.pos.y++;
    }
    player.pos.y--;
    merge(arena, player);
    sfx.drop();
    
    // Screen Shake
    const wrapper = document.getElementById('game-wrapper');
    wrapper.classList.remove('shake');
    void wrapper.offsetWidth;
    wrapper.classList.add('shake');

    playerReset();
    arenaSweep();
    updateScore();
    dropCounter = 0;
}

function playerHold() {
    if (!player.canHold) return;
    sfx.hold();
    if (player.hold === null) {
        player.hold = player.matrix;
        playerReset(true);
    } else {
        const temp = player.matrix;
        player.matrix = player.hold;
        player.hold = temp;
        player.pos.y = 0;
        player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
    }
    player.canHold = false;
    drawSidePanel(holdContext, player.hold);
}

let nextPiece = null;
function playerReset(isHoldSwap = false) {
    if(!isHoldSwap) {
        if (nextPiece === null) nextPiece = createPiece('ILJOTSZ'[Math.random() * 7 | 0]);
        player.matrix = nextPiece;
        nextPiece = createPiece('ILJOTSZ'[Math.random() * 7 | 0]);
        player.canHold = true;
    }
    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
        isGameOver = true;
        isGameActive = false;
        sfx.gameOver();
        if(isMusicPlaying) toggleMusic(); // Stop music on death
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('final-score').innerText = player.score;
    }
    drawSidePanel(nextContext, nextPiece);
    drawSidePanel(holdContext, player.hold);
}

function arenaSweep() {
    let rowCount = 0;
    outer: for (let y = arena.length - 1; y > 0; --y) {
        for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) continue outer;
        }
        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        ++y;
        rowCount++;
        
        // Particle Explosion
        for(let i=0; i<15; i++) {
            particles.push({
                x: Math.random() * 10,
                y: y + Math.random(),
                vx: (Math.random() - 0.5) * 0.8,
                vy: (Math.random() - 1.5) * 0.5,
                life: 30 + Math.random()*20,
                color: `hsl(${Math.random() * 50 + 180}, 100%, 50%)` // Cyan/Blue hues
            });
        }
    }
    
    if (rowCount > 0) {
        sfx.clear();
        player.score += rowCount * 100 * rowCount;
        player.lines += rowCount;
        player.level = Math.floor(player.lines / 10) + 1;
        dropInterval = Math.max(100, 1000 - (player.level * 50));
        
        if (player.score > highScore) {
            highScore = player.score;
            localStorage.setItem('neon_tetris_highscore', highScore);
            document.getElementById('high-score').innerText = highScore;
        }
    }
}

function updateScore() {
    document.getElementById('score').innerText = player.score;
    document.getElementById('level').innerText = player.level;
    document.getElementById('lines').innerText = player.lines;
}

let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

function update(time = 0) {
    if(!isPaused && !isGameOver && isGameActive) {
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            playerDrop();
        }
        draw();
    }
    requestAnimationFrame(update);
}

// Controls
const keys = {
    37: () => playerMove(-1),
    39: () => playerMove(1),
    40: () => playerDrop(),
    38: () => playerRotate(1),
    32: () => playerHardDrop(),
    67: () => playerHold(),
    80: () => togglePause(),
    77: () => toggleMusic() // M key
};

document.addEventListener('keydown', event => {
    if (event.keyCode === 77) { keys[77](); return; } // Always allow music toggle
    if(!isGameActive) return;
    if (keys[event.keyCode]) {
        event.preventDefault();
        if(isPaused && event.keyCode !== 80) return;
        keys[event.keyCode]();
    }
});

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    isGameActive = true;
    playerReset();
    updateScore();
    update();
    if(audioCtx.state === 'suspended') audioCtx.resume();
    if(!isMusicPlaying) toggleMusic(); // Auto-start music
}

function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.lines = 0;
    player.level = 1;
    player.hold = null;
    player.canHold = true;
    dropInterval = 1000;
    isGameOver = false;
    isGameActive = true;
    document.getElementById('game-over').classList.add('hidden');
    playerReset();
    updateScore();
    if(!isMusicPlaying) toggleMusic();
}

function togglePause() {
    isPaused = !isPaused;
    const screen = document.getElementById('pause-screen');
    if(isPaused) {
        screen.classList.remove('hidden');
        if(isMusicPlaying) toggleMusic(); // Stop music on pause
    } else {
        screen.classList.add('hidden');
        lastTime = performance.now();
        if(!isMusicPlaying) toggleMusic(); // Resume music
    }
}
</script>
</body>
</html>