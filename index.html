<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Tetris: Enhanced</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #050505;
            --text-color: #fff;
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --ui-bg: rgba(20, 20, 20, 0.9);
        }

        body {
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Layout Containers */
        #game-container {
            position: relative;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #game-wrapper {
            position: relative;
            border: 4px solid #333;
            border-radius: 4px;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
        }

        canvas {
            display: block;
            background-color: #000;
        }

        /* Sidebars */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 120px;
        }

        .sidebar.left { text-align: right; }
        .sidebar.right { text-align: left; }

        .panel {
            background: var(--ui-bg);
            padding: 15px 10px;
            border: 2px solid #444;
            text-align: center;
            box-shadow: inset 0 0 15px #000;
            border-radius: 8px;
        }

        .panel h3 {
            font-size: 10px;
            color: #888;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .value {
            font-size: 16px;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        /* Canvas Styling */
        #tetris { border-right: 1px solid #222; border-left: 1px solid #222; }
        #hold, #next { 
            margin: 0 auto; 
            background: transparent;
        }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            text-align: center;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 40px;
            color: var(--neon-pink);
            text-shadow: 3px 3px 0px var(--neon-blue);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        button {
            background: var(--neon-blue);
            color: #000;
            border: none;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-blue);
            transition: transform 0.1s;
        }

        button:hover { transform: scale(1.05); background: #fff; }
        button:active { transform: scale(0.95); }

        /* Shake Animation */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            100% { transform: translate(0, 0) rotate(0); }
        }

        .shake { animation: shake 0.3s; }

        /* Controls Text */
        #controls-hint {
            margin-top: 30px;
            font-size: 10px;
            color: #666;
            text-align: center;
            line-height: 2;
        }
        .key { border: 1px solid #555; padding: 4px 6px; border-radius: 4px; color: #ddd; background: #222; }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div class="sidebar left">
            <div class="panel">
                <h3>Hold</h3>
                <canvas id="hold" width="80" height="80"></canvas>
            </div>
            <div class="panel">
                <h3>Lines</h3>
                <div id="lines" class="value">0</div>
            </div>
        </div>

        <div id="game-wrapper">
            <canvas id="tetris" width="240" height="400"></canvas>
            
            <div id="start-screen" class="overlay">
                <h1>NEON<br>TETRIS</h1>
                <button onclick="startGame()">PLAY GAME</button>
                <p style="font-size: 10px; margin-top: 20px; color:#666;">Enable Audio</p>
            </div>

            <div id="game-over" class="overlay hidden">
                <h1 style="color: red; text-shadow: none;">GAME OVER</h1>
                <p>SCORE</p>
                <div id="final-score" class="value" style="margin-bottom: 20px; font-size: 24px;">0</div>
                <button onclick="resetGame()">TRY AGAIN</button>
            </div>

            <div id="pause-screen" class="overlay hidden">
                <h1>PAUSED</h1>
                <button onclick="togglePause()">RESUME</button>
            </div>
        </div>

        <div class="sidebar right">
            <div class="panel">
                <h3>Next</h3>
                <canvas id="next" width="80" height="80"></canvas>
            </div>
            <div class="panel">
                <h3>Score</h3>
                <div id="score" class="value">0</div>
            </div>
            <div class="panel">
                <h3>Level</h3>
                <div id="level" class="value">1</div>
            </div>
        </div>
    </div>

    <div id="controls-hint">
        <span class="key">←</span> <span class="key">→</span> Move &nbsp; 
        <span class="key">↑</span> Rotate &nbsp; 
        <span class="key">↓</span> Soft Drop<br>
        <span class="key">SPACE</span> Hard Drop &nbsp; 
        <span class="key">C</span> Hold Piece &nbsp; 
        <span class="key">P</span> Pause
    </div>

<script>
// --- AUDIO SYSTEM (Web Audio API) ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

const sound = {
    playTone: (freq, type, duration, vol = 0.1) => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },
    move: () => sound.playTone(200, 'triangle', 0.05, 0.05),
    rotate: () => sound.playTone(400, 'square', 0.1, 0.05),
    drop: () => sound.playTone(100, 'sawtooth', 0.2, 0.1),
    hold: () => sound.playTone(300, 'sine', 0.1, 0.1),
    clear: () => {
        sound.playTone(523.25, 'square', 0.1, 0.1); // C
        setTimeout(() => sound.playTone(659.25, 'square', 0.1, 0.1), 50); // E
        setTimeout(() => sound.playTone(783.99, 'square', 0.2, 0.1), 100); // G
    },
    tetris: () => {
        // Major chord fanfare
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            setTimeout(() => sound.playTone(freq, 'sawtooth', 0.4, 0.15), i * 40);
        });
    },
    gameOver: () => {
        sound.playTone(300, 'sawtooth', 0.5, 0.2);
        setTimeout(() => sound.playTone(250, 'sawtooth', 0.5, 0.2), 300);
        setTimeout(() => sound.playTone(200, 'sawtooth', 1.0, 0.2), 600);
    }
};

// --- GAME LOGIC ---
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nextContext = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('hold');
const holdContext = holdCanvas.getContext('2d');

// Scaling
context.scale(20, 20);
nextContext.scale(20, 20);
holdContext.scale(20, 20);

// Colors
const colors = [
    null,
    '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', 
    '#FF8E0D', '#FFE138', '#3877FF'
];

let particles = [];
let isPaused = false;
let isGameOver = false;
let isGameActive = false;

// Game State
const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    score: 0,
    lines: 0,
    level: 1,
    hold: null,
    canHold: true
};

const arena = createMatrix(10, 20);

function createPiece(type) {
    if (type === 'I') return [[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0],[0, 1, 0, 0]];
    if (type === 'L') return [[0, 2, 0],[0, 2, 0],[0, 2, 2]];
    if (type === 'J') return [[0, 3, 0],[0, 3, 0],[3, 3, 0]];
    if (type === 'O') return [[4, 4],[4, 4]];
    if (type === 'Z') return [[5, 5, 0],[0, 5, 5],[0, 0, 0]];
    if (type === 'S') return [[0, 6, 6],[6, 6, 0],[0, 0, 0]];
    if (type === 'T') return [[0, 7, 0],[7, 7, 7],[0, 0, 0]];
}

function createMatrix(w, h) {
    const matrix = [];
    while (h--) matrix.push(new Array(w).fill(0));
    return matrix;
}

function drawMatrix(matrix, offset, ctx, ghost = false) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                if (ghost) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 0.05;
                    ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                } else {
                    ctx.fillStyle = colors[value];
                    ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                    ctx.lineWidth = 0.05;
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                    ctx.fillStyle = 'rgba(0,0,0,0.1)'; // Inner shading
                    ctx.fillRect(x + offset.x + 0.2, y + offset.y + 0.2, 0.6, 0.6);
                }
            }
        });
    });
}

function draw() {
    // Main Board
    context.fillStyle = '#000';
    context.fillRect(0, 0, canvas.width, canvas.height);
    drawMatrix(arena, {x: 0, y: 0}, context);

    // Ghost Piece
    if(player.matrix && !isGameOver) {
        const ghostPos = {...player.pos};
        while (!collide(arena, {matrix: player.matrix, pos: ghostPos})) {
            ghostPos.y++;
        }
        ghostPos.y--;
        drawMatrix(player.matrix, ghostPos, context, true);
        drawMatrix(player.matrix, player.pos, context);
    }

    // Particles
    particles.forEach((p, i) => {
        p.life--;
        p.x += p.vx;
        p.y += p.vy;
        context.fillStyle = p.color;
        context.fillRect(p.x, p.y, 0.15, 0.15);
        if(p.life <= 0) particles.splice(i, 1);
    });
}

function drawSidePanel(ctx, matrix) {
    ctx.fillStyle = '#000'; // Transparent/Black bg
    ctx.clearRect(0, 0, 4, 4); // Clear 4x4 area (since we scaled)
    if (matrix) {
        const offset = {
            x: (4 - matrix[0].length) / 2,
            y: (4 - matrix.length) / 2
        };
        drawMatrix(matrix, offset, ctx);
    }
}

function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 &&
               (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                return true;
            }
        }
    }
    return false;
}

function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
        });
    });
}

function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
}

function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        sound.drop();
        playerReset();
        arenaSweep();
        updateScore();
        shakeScreen(2);
    }
    dropCounter = 0;
}

function playerMove(dir) {
    player.pos.x += dir;
    if (collide(arena, player)) {
        player.pos.x -= dir;
    } else {
        sound.move();
    }
}

function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
            rotate(player.matrix, -dir);
            player.pos.x = pos;
            return;
        }
    }
    sound.rotate();
}

function playerHardDrop() {
    let dropDist = 0;
    while (!collide(arena, player)) {
        player.pos.y++;
        dropDist++;
    }
    player.pos.y--;
    merge(arena, player);
    sound.drop();
    playerReset();
    arenaSweep();
    updateScore();
    shakeScreen(5);
    dropCounter = 0;
}

function playerHold() {
    if (!player.canHold) return;
    
    sound.hold();
    if (player.hold === null) {
        player.hold = player.matrix;
        playerReset(true); // True = don't spawn new if taking from hold? No, spawning new.
    } else {
        const temp = player.matrix;
        player.matrix = player.hold;
        player.hold = temp;
        player.pos.y = 0;
        player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
    }
    
    // Fix hold rotation (sometimes they get stored rotated)
    // Actually, simplest is to just re-create the piece based on type, 
    // but for this simple engine we store the matrix. 
    // Let's just reset position.
    
    player.canHold = false;
    drawSidePanel(holdContext, player.hold);
}

let nextPiece = null;
function playerReset(isHoldSwap = false) {
    if(!isHoldSwap) {
        if (nextPiece === null) nextPiece = createPiece('ILJOTSZ'[Math.random() * 7 | 0]);
        player.matrix = nextPiece;
        nextPiece = createPiece('ILJOTSZ'[Math.random() * 7 | 0]);
        player.canHold = true;
    }

    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
        isGameOver = true;
        isGameActive = false;
        sound.gameOver();
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('final-score').innerText = player.score;
    }
    
    drawSidePanel(nextContext, nextPiece);
    drawSidePanel(holdContext, player.hold); // Refresh hold view
}

function arenaSweep() {
    let rowCount = 0;
    outer: for (let y = arena.length - 1; y > 0; --y) {
        for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) continue outer;
        }
        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        ++y;
        rowCount++;
        
        // Explosion Particles
        for(let i=0; i<20; i++) {
            particles.push({
                x: Math.random() * 10,
                y: y + Math.random(),
                vx: (Math.random() - 0.5) * 0.8,
                vy: (Math.random() - 0.5) * 0.8,
                life: 40,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`
            });
        }
    }
    
    if (rowCount > 0) {
        if(rowCount === 4) sound.tetris();
        else sound.clear();
        
        player.score += rowCount * 100 * rowCount; // 100, 400, 900, 1600
        player.lines += rowCount;
        player.level = Math.floor(player.lines / 10) + 1;
        dropInterval = Math.max(100, 1000 - (player.level * 50));
    }
}

function updateScore() {
    document.getElementById('score').innerText = player.score;
    document.getElementById('level').innerText = player.level;
    document.getElementById('lines').innerText = player.lines;
}

function shakeScreen(intensity) {
    const wrapper = document.getElementById('game-wrapper');
    wrapper.classList.remove('shake');
    void wrapper.offsetWidth; // Trigger reflow
    wrapper.classList.add('shake');
}

// Game Loop
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

function update(time = 0) {
    if(!isPaused && !isGameOver && isGameActive) {
        const deltaTime = time - lastTime;
        lastTime = time;

        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            playerDrop();
        }

        draw();
    }
    requestAnimationFrame(update);
}

// Controls
const keys = {
    37: () => playerMove(-1),
    39: () => playerMove(1),
    40: () => playerDrop(),
    38: () => playerRotate(1),
    32: () => playerHardDrop(),
    67: () => playerHold(), // C
    80: () => togglePause(), // P
};

document.addEventListener('keydown', event => {
    if(!isGameActive) return;
    if (keys[event.keyCode]) {
        event.preventDefault();
        if(isPaused && event.keyCode !== 80) return;
        keys[event.keyCode]();
    }
});

// UI Functions
function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    isGameActive = true;
    playerReset();
    updateScore();
    update();
    audioCtx.resume(); // Browser requires gesture to start audio
}

function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.lines = 0;
    player.level = 1;
    player.hold = null;
    player.canHold = true;
    dropInterval = 1000;
    isGameOver = false;
    isGameActive = true;
    document.getElementById('game-over').classList.add('hidden');
    playerReset();
    updateScore();
}

function togglePause() {
    isPaused = !isPaused;
    const screen = document.getElementById('pause-screen');
    if(isPaused) screen.classList.remove('hidden');
    else {
        screen.classList.add('hidden');
        lastTime = performance.now(); // Prevent huge drop on resume
    }
}

</script>
</body>
</html>